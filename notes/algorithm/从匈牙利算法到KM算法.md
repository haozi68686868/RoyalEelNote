# 从匈牙利算法到KM算法

网上搜了好多KM算法的文章，都写得云里雾里。看了半天之后，我终于看懂了。其实KM算法非常简单，只要会匈牙利算法了，一下就能看懂KM算法。

如果大家对自己的匈牙利算法不够自信的话，可以先复习一下，放上我的上一篇文章。

[https://zhuanlan.zhihu.com/p/208596378zhuanlan.zhihu.com![图标](https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg)](https://zhuanlan.zhihu.com/p/208596378)

## KM算法是解决什么问题的?

要知道，最大匹配不是唯一的，不同的人用匈牙利算法，可能找到不同的匹配结果。那么怎么评估这些不同的匹配呢？还是拿情侣配对举例子，一种评价方法就是，看情侣彼此的满意程度。比如，有的人当媒人，介绍的每一对情侣都极其满意，有的人当媒人，虽然把情侣都凑在了一起，介绍的每一对情侣只是略微有意向，但是没和最喜欢的在一起。

这个喜欢程度，就是给原本的二分图，加了一个权重。

![img](https://pic2.zhimg.com/80/v2-80359d35ccbe7dd9a32fa3e20f7f1211_720w.jpg)图1 权重二分图的最大匹配问题

在权重的前提下，该如何寻找最大匹配，且使得权重最大呢？KM算法就是为了解决这个问题的。

## 权重问题的转化 / KM算法和匈牙利算法的关系

我刚开始学习的时候，根本没有想明白，KM算法和匈牙利算法的关系。

遇到不会的问题，一个思路就是想办法转换成自己会的问题。我们现在知道匈牙利算法能解决最大匹配的问题，现在加了权重，KM算法实际上就是想了个办法，将问题转换成了匈牙利算法可以解决的形式。

现在二分图带了权重，可以理解为加了一种约束，这种约束让我们优先选择那些权重大的边出来，进行匹配。

因此我们要先把权重最大的边都挑出来，学术一点，就是挑一个子图出来。**因为我们挑出来的都是权重最大的边，我们只要在这个子图中，找到最大匹配，这个最大匹配一定是权重最大的（很重要，意思就是这个子图里，在上面随便找都是权重最大的匹配，这样我们就能用匈牙利算法解决问题了）。**流程就是：

```text
找权重最大的边组成的子图--------→在这个子图上找最大匹配
```

上述流程很简单吧，有一个问题是，我们都找最大权重的边组成子图，这个子图很小，很容易冲突。形象来说，大家找对象的要求都太高了，很可能会没法满足他们的要求。众所周知，找不到对象是很惨的，因此对象还是得找的。这时候只能委屈一部分人，让他稍微降低一下的要求，让他从别的人里挑对象。

因此目前的流程变成了：

```abap
                                                        -----------→ 找到最大匹配（结束）
                                                        ↑
找权重最大的边组成的子图--------→在这个子图上找最大匹配----------→冲突发生，不能调和-----
                                        ↑                                          ↓
                                  扩大择偶范围（子图）←-----降低要求←----------------- 
```

这个KM算法的流程，核心思想就是：优先选择最满意的，因为要求太高找不到对象的那些人，降低标准扩大择偶范围，直到找到对象为止。

这个问题中，找最大匹配的那一部分我们会了呀，用匈牙利算法就搞定了。剩下就是两个问题了：

（1）怎么找到这个所谓的“权重最大的子图”。

（2）怎么扩大择偶范围。既不能降得太低，也不能不降。

上述两个问题，就是KM算法的精髓。

这个权重最大的子图，就是“相等子图”。扩大择偶范围，就是“顶标的更新---建立新的相等子图”的过程。

要注意的是，上面说的权重最大，并不是整个图的范围内权重越大越好，而是目前能力范围内我们能选的最大的权重边（毕竟有些人需要降低标准才能找到对象）。

接下来就要讲如何解决上面提出的两个问题。

## 第一个问题 如何寻找“权重最大的”子图？

首先强调一点，我们的这个子图的目的，是为了实现一个效果：

**在这个子图上，不考虑权重找到最大匹配** 等价于 **在带权重的图上找权重最大的最大匹配**。

我们挑一伙人出来，这些人彼此的满意度都比较高，那些低的暂时不考虑。在这伙人里找对象。找不到了再考虑加人进来。

为了实现这个目标，我们给每个人，增加一个顶标。我们暂不考虑这个顶标是怎么加的，将在下一步中再详细讲这个问题。现在假设我们已经有一个顶标了。

这个顶标是我们决定一条边是否加入子图的依据。顶标可以理解为择偶的***最高\***标准，如果双方的适配程度达到了这个最高标准，就加入到择偶范围内来，就是加入到子图中。

因此，比如说小王择偶的***最高\***标准是 ![[公式]](https://www.zhihu.com/equation?tex=S_%7Bwang%7D) ，小李择偶***最高\***标准![[公式]](https://www.zhihu.com/equation?tex=S_%7Bli%7D)。小王和小李的喜欢程度是 ![[公式]](https://www.zhihu.com/equation?tex=W) （即二分图中，小王和小李的连线权重），若

![[公式]](https://www.zhihu.com/equation?tex=S_%7Bwang%7D%2BS_%7Bli%7D+%3D+W),

小王和小李的连线就加入子图中，进入择偶候选人范围。注意到上面这个等式，于是这样选出来的子图，叫做相等子图。

然而这个***最高\***标准，是不断变化的。也就是下一个问题，如何不断地调整***最高\***标准，让择偶范围不断变化。

## 第二个问题 如何扩大择偶范围？

我们这里拿一个具体的例子来看。

这里有5个女生x1-x5， 5个男生y1-y5。他们之间为0就是没有连线，大于0的数是权重，就是他们相互喜欢的程度。

![img](https://pic1.zhimg.com/80/v2-49b5a6121755e8929c6c40dcca15d058_720w.jpg)

**第一步，最高标准初始化。**

需要注意的是，我们是一个无向的二分图，意思就是权重是双方共同的喜欢程度，因此可以选一个人作为代表就行了。于是，我们让女生做单方面的选择。

**于是男生们的顶标都设为0。**

一开始女生们都想找最喜欢的对象，我们将她们的最高标准都设为她们最喜欢的那个。比如，x1对所有男生都有意向，喜欢程度分别是3,5,5,4,1。那小王目前的最高标准就是5。

在第一次选择中，y2、y3加入择偶范围，其他三人暂不考虑。**所有女生都这样，选出自己最喜欢的加入择偶范围。**

我们就得到了子图

![img](https://pic1.zhimg.com/80/v2-d41065309a9ebbebaba9697c72efd5b4_720w.jpg)

这样的好处就是，这样挑出来的子图中，彼此喜欢程度一定是最大的。这样我们就不用考虑权重的问题了，问题就变成了一个在局部子图上，挑选最大匹配的问题，就可以用匈牙利算法解决了。

接下来，我们就用匈牙利算法来给她们分配对象。红线表示匹配好了。

![img](https://pic3.zhimg.com/80/v2-b2d98809832909f5874df7345e005152_720w.jpg)

x1和x2都成功找到了对象。但是x3也愿意和y2一起。冲突了。一开始有了矛盾，我们先用匈牙利算法给她们尝试解决一下。

我们找到一条增广路，x3---y2---x1----y3。取个反，冲突就解决了。x3也找到了自己最满意的对象。

![img](https://pic4.zhimg.com/80/v2-e0c9824569b8e0f5908bb48f145d276f_720w.jpg)

轮到x4了。x4最满意的是y2和y3，但是都被挑走了。我们先用匈牙利算法，给她也试一下。开始找增广路。x4----y2----x3----y3------x1----y2----????，发现到了y2，找不下去了，又回到y3了。 我们优先广度，试试另一条路。 x4----y3-----x1------y2-----x3------y3----???，发现又找不下去了。

此时此刻，匈牙利算法也解决不了了，就要开始扩大择偶范围了。

**第二步，最高标准调整。**

我们随便选择一条上面没走下去的交替路（由于没有成功找到另一个未匹配的对象，所以这条交替路没有资格被称为增广路）比如就选这条：

x4----y2----x3----y3------x1----y2----????

这条路线，在很多文章里也会被成为交替树。一旦找到增广路，我们就能扩大匹配范围，给x4也找到对象。但是现在失败了，这个失败的本质是和路线上的人发生了冲突。2

于是我们看看，有哪些人和x4的失败有关。女生：x1，x3，x4。男生：y2，y3。

现在我们要协调这几个人的择偶最高标准（也就是他们的顶标），扩大择偶范围了。

首先，我们不能破坏原有的关系，原来的顶标都是设计好的，能保证选到自己最喜欢的对象。所以要保证他们之间最高标准不变，这样保证原来的匹配不会发生变化。

这里让上面和x4冲突的这些人里：女生的顶标减少，男生顶标增加，这样他俩合起来标准不变。

但是，女生的顶标减小了，其他人的机会就来了。

再回到刚刚我们挑子图的公式，就是小王配小李的这个等式，

![[公式]](https://www.zhihu.com/equation?tex=S_%7Bwang%7D%2BS_%7Bli%7D+%3D+W),

现在小王因为和别人冲突了，降低了标准，W就减小了，也就是有些权重没那么大的边，现在有机会被加进子图里了。

现在女生：x1，x3，x4都喜欢y2和y3，发生冲突了，而y1,y4,y5还没被他们考虑。原本x1的标准是5，现在她要考虑y1的话，x1y1权重是3，需要降低2个标准。

同理，x1y4需要降低1； x3y1需要降低2， x3y4需要降低4-1=3；x3y5需要降低4-0=4。x4也一样算法。

所以考虑到最大权重，最少要降低1个标准。

因此我们把x1，x3，x4的标准-1，y2，y3对应+1。

![img](https://pic2.zhimg.com/80/v2-485c7de0c80a4176125010df8afe76c1_720w.jpg)

在这个标准下，我们依旧要挑满足“两人顶标和=两人连线权重”的边。

![img](https://pic4.zhimg.com/80/v2-aa2ea762729bd58cbccb7baf40eb04af_720w.jpg)

可以看出来，x4同学降低标准后，所有男同学都满足她的标准了。

![img](https://pic1.zhimg.com/80/v2-61229f246e0cdde891e5b45f7719c44c_720w.jpg)

这时候按照匈牙利算法，x4和y1配对，冲突了，找到增广路x4---y1---x2---y4。取反后，x4和y1配对，x2和y4配对。

![img](https://pic2.zhimg.com/80/v2-48fb7a258e6b901f61096c2553095041_720w.jpg)

再给x5找对象。x5也找到了y5作为对象。

![img](https://pic3.zhimg.com/80/v2-51d28f52efd5d822280d3d0ba2540a9e_720w.jpg)

现在所有人都有对象了。

此时他们的权重为4+2+3+0+3+0+1+1 +0+0 =14。



### KM算法
求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。该算法描述如下：

1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。

2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。

什么是相等子图呢？因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。

如果从X部中的某个点Xi出发在相等子图中没有找到增广路径，我们是如何修改顶标的呢？如果我们没有找到增广路径，则我们一定找到了许多条从Xi出发并结束于X部的匹配边与未匹配边交替出现的路径，姑且称之为交错树。我们将交错树中X部的顶点顶标减去一个值d，交错树中属于Y部的顶点顶标加上一个值d。这个值后面要讲它如何计算。那么我们会发现：

两端都在交错树中的边(i,j)，其顶标和没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。

两端都不在交错树中的边(i,j)，其顶标也没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。

X端不在交错树中，Y端在交错树中的边(i,j)，它的顶标和会增大。它原来不属于相等子图，现在仍不属于相等子图。

X端在交错树中，Y端不在交错树中的边(i,j),它的顶标和会减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。

我们修改顶标的目的就是要扩大相等子图。为了保证至少有一条边进入相等子图，我们可以在交错树的边中寻找顶标和与边权之差最小的边,这就是前面说的d值。将交错树中属于X部的顶点减去d，交错树中属于Y部的顶点加上d。则可以保证至少有一条边扩充进入相等子图。

3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。

————————————————
版权声明：本文为CSDN博主「C20180630_zjf」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/c20180630/article/details/71080521



```c++
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;
const int MAXN = 305;
const int INF = 0x3f3f3f3f;

int love[MAXN][MAXN];   // 记录每个妹子和每个男生的好感度
int ex_girl[MAXN];      // 每个妹子的期望值
int ex_boy[MAXN];       // 每个男生的期望值
bool vis_girl[MAXN];    // 记录每一轮匹配匹配过的女生
bool vis_boy[MAXN];     // 记录每一轮匹配匹配过的男生
int match[MAXN];        // 记录每个男生匹配到的妹子 如果没有则为-1
int slack[MAXN];        // 记录每个汉子如果能被妹子倾心最少还需要多少期望值

int N;


bool dfs(int girl)
{
    vis_girl[girl] = true;

    for (int boy = 0; boy < N; ++boy) {

        if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次

        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];

        if (gap == 0) {  // 如果符合要求
            vis_boy[boy] = true;
            if (match[boy] == -1 || dfs( match[boy] )) {    // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人
                match[boy] = girl;
                return true;
            }
        } else {
            slack[boy] = min(slack[boy], gap);  // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸
        }
    }

    return false;
}

int KM()
{
    memset(match, -1, sizeof match);    // 初始每个男生都没有匹配的女生
    memset(ex_boy, 0, sizeof ex_boy);   // 初始每个男生的期望值为0

    // 每个女生的初始期望值是与她相连的男生最大的好感度
    for (int i = 0; i < N; ++i) {
        ex_girl[i] = love[i][0];
        for (int j = 1; j < N; ++j) {
            ex_girl[i] = max(ex_girl[i], love[i][j]);
        }
    }

    // 尝试为每一个女生解决归宿问题
    for (int i = 0; i < N; ++i) {

        fill(slack, slack + N, INF);    // 因为要取最小值 初始化为无穷大

        while (1) {
            // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止

            // 记录每轮匹配中男生女生是否被尝试匹配过
            memset(vis_girl, false, sizeof vis_girl);
            memset(vis_boy, false, sizeof vis_boy);

            if (dfs(i)) break;  // 找到归宿 退出

            // 如果不能找到 就降低期望值
            // 最小可降低的期望值
            int d = INF;
            for (int j = 0; j < N; ++j)
                if (!vis_boy[j]) d = min(d, slack[j]);

            for (int j = 0; j < N; ++j) {
                // 所有访问过的女生降低期望值
                if (vis_girl[j]) ex_girl[j] -= d;

                // 所有访问过的男生增加期望值
                if (vis_boy[j]) ex_boy[j] += d;
                // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！
                else slack[j] -= d;
            }
        }
    }

    // 匹配完成 求出所有配对的好感度的和
    int res = 0;
    for (int i = 0; i < N; ++i)
        res += love[ match[i] ][i];

    return res;
}

int main()
{
    while (~scanf("%d", &N)) {

        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                scanf("%d", &love[i][j]);

        printf("%d\n", KM());
    }
    return 0;
}
```

