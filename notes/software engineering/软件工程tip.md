#### DRY 原则

Don't Repeat Yourself Principle 

#### RASIC

R - Responsible 负责人：对举措的实施负责，采取行动来确保各项任务的实施

A - Accountable 决策者：授权对决策进行审批，只有经其同意或确认后，决策才可以生效

S - Support 支持方：参与并支持举措的实施，提供必要的数据，人员和其他资源

I - Inform 需被告知方：举措会对某些部门工作产生影响，因此必须告知这些部门/人员举措的结果，负责人有责任向其沟通

C - consult 需被咨询方：决策之前必须向某些部分进行咨询。通常不是决策的直接参与者

#### ETC

Easy to Change 更容易变更

#### DBC 契约式设计

##### 前置条件

- 一个例程不应被前置条件违反时被调用，传递良好的数据是调用者的责任。

##### 后置条件

- 需保证例程完成时，世界的状态，另外也就不允许无限循环

##### 类的不变式



##### 算法的复杂度 - 最好的不会永远最好

- 不要过早的优化，在投入宝贵的时间尝试改进算法之前，请确保算法确实是瓶颈！



##### 测试的哲学

- 针对契约测试
  - 确保该报错的会报错
  - 各种普通的值能正确
- 模块组合测试，以一个模块A使用了B+C
  - B的契约
  - C的契约
  - 模块A自身的契约
- 所有的软件最终都会被测试，如果不是由你或你的团队做测试，将由用户去测试！



##### 安全性

- 将攻击面的面积最小化
- 最小特权原则
- 安全的默认值
- 敏感数据要加密
- 维护安全更新

##### 面向对象设计哲学

1. 针对接口编程，而不是针对实现编程
2. 优先使用对象组合，而不是类继承

##### 面向对象六大原则

1. 单一职责：Single Responsibility
2. 开闭原则：Open-Closed Principle
   - 应该对扩展开发，而对修改关闭
   - 关键：抽象化、接口、抽象类
   - 抽象层尽量保持稳定，一旦确定就不允许修改。
3. 里氏替换原则：Liskov Substitution Principle
   - 任何基类出现的地方，子类一定可以出现（程序不会出错）
4. 依赖倒置原则：Dependence Inversion Principle
   - 抽象不应该依赖于细节，细节应该依赖于抽象
   - 要针对接口编程，而不是针对实现编程
5. 接口隔离原则：Interface Segregation Principle
   - 使用多个专门的接口，而不是单一的总接口
   - 应该依赖需要的接口，不依赖用不到的
6. 合成复用原则：Composite Reuse Principle
   - 优先使用组合/聚合，而不是继承
7. 迪米特法则：Law of Demeter
   - 软件实体应当尽可能与其他实体发生相互作用
   - 减少直接耦合，横向纵向耦合，多采用中介的方式，如facade和mediator模式
   - 关键词：松耦合

##### 好的系统设计特质

1. 可扩展性（Extensibility）
2. 灵活性（Flexibility）
3. 可插拔性（Pluggability）